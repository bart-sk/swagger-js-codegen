/* tslint:disable */
import 'isomorphic-fetch';

{{#imports}}
/// <reference path="{{&.}}" />
{{/imports}}

type QueryParameters = { [key: string]: string | number | string[] | number[] };

{{#definitions}}
export type {{&name}} = {{#tsType}}{{> type}}{{/tsType}};
{{/definitions}}

class ApiError {
  public message: string;
  public details: Error;

  constructor(message: string) {
    this.message = message;
  }
}

class RestError {
  public message: string;
  public details: {
      message: string;
      description: string;
      name: string;
      stack: string;
  };

  constructor(message: string) {
    this.message = message;
    this.details = {
        message,
        description: message,
        name: message,
        stack: message
    };
  }
}

/**
 * {{&description}}
 * @class {{&className}}
 * @param {(string)} [domainOrOptions] - The project domain.
 */
class {{&className}} {

    public baseUrl: string = "{{&domain}}";
    public token: string;

    serializeQueryParams(parameters: QueryParameters) {
        const str: string[] = [];
        for (let p in parameters) {
        if (parameters.hasOwnProperty(p)) {
            str.push(`${encodeURIComponent(p)}=${encodeURIComponent(parameters[p].toString())}`);
        }
        }
        return str.join('&');
    }

    private async request(method: string, url: string, body: any, headers: any, queryParameters: QueryParameters, form: any) {
        const queryParams = queryParameters && Object.keys(queryParameters).length ? this.serializeQueryParams(queryParameters) : null ;
        const urlWithParams = url + (queryParams ? '?' + queryParams : '');

        // ugly hack, we need to delete Content-Type header with multipart/form-data
        // that way, browser will calculate form specific headers on it's own
        // contentTypeHeader[0] because nearly every header's value is set using array
        const contentTypeHeader = headers['Content-Type'];
        if(contentTypeHeader && contentTypeHeader[0] === 'multipart/form-data') {
        delete headers['Content-Type'];
        }

        if (body && !Object.keys(body).length) {
        body = undefined;
        } else {
        body = JSON.stringify(body);
        }

        if (form && Object.keys(form).length) {
        body = new FormData();
        for (let k in form) {
            body.append(k, form[k]);
        }
        }

        const response = await fetch(urlWithParams, { method, headers, body });
        if(response.ok) {
            return response.json();
        } else {
            const err = new ApiError(response.statusText);
            err.details = await response.json();
            throw err;
        }
    }

{{#methods}}
    {{> method}}

{{/methods}}
}

export default new {{&className}}();
